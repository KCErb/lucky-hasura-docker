#!/bin/bash
# Exit if any subcommand fails
set -e
set -o pipefail

source "${BASH_SOURCE%/*}/functions/commons"
source "${BASH_SOURCE%/*}/functions/update_code"

# deploy tools read from env, so if we are not in production
# we can provide some default values for dev purposes.
if [ "$LUCKY_ENV" != "production" ]; then
  export POSTGRES_PASSWORD=secret
  export POSTGRES_USER=admin
  export POSTGRES_DB=project_local_prod
  export HASURA_GRAPHQL_ADMIN_SECRET=secret
  export SECRET_KEY_BASE=secret
  export SEND_GRID_KEY=fake_key
  export APP_DOMAIN=localhost
  export LUCKY_ENV=production
fi

# type is set to arg if available, defaults to add
ARG=$@
TYPE="${ARG:-add}"
export LUCKY_TAG=`git rev-parse --short=8 HEAD`

function migrate {
  printf "\n▸ Running update-db\n"
  docker run --rm --env-file ./Docker/lucky/migrations.env -e DATABASE_URL=postgres://$POSTGRES_USER:$POSTGRES_PASSWORD@postgres:5432/$POSTGRES_DB --net migrations --entrypoint /data/script/docker/update-db registry.gitlab.com/GITLAB_USER/GITLAB_REPO_NAME/lucky:$LUCKY_TAG | indent
}

# additive migrations add to the db, so the new code relies on new stuff in the db
# and that means we have update the db first.
# subtractive take away from the db, so the old code will break so we first deploy the new code
# which ignores the stuff we're about to take away and then takes it away.
if [ "$TYPE" = "add" ]; then
  migrate
  update_code
else
  update_code
  migrate
fi

printf "\n✔ All done.\n"
