#!/bin/bash
# Exit if any subcommand fails
set -e
set -o pipefail

source "${BASH_SOURCE%/*}/functions/commons"
source "${BASH_SOURCE%/*}/functions/update_code"
source "${BASH_SOURCE%/*}/functions/rollback_db"

# deploy tools read from env, so if we are not in production
# we can provide some default values for dev purposes.
if [ "$LUCKY_ENV" != "production" ]; then
  export POSTGRES_PASSWORD=secret
  export POSTGRES_USER=admin
  export POSTGRES_DB=project_local_prod
  export HASURA_GRAPHQL_ADMIN_SECRET=secret
  export SECRET_KEY_BASE=secret
  export SEND_GRID_KEY=fake_key
fi

# Read in -s flag if provided
TYPE='add'
while getopts 's' flag; do
  case "${flag}" in
    s) TYPE='subtract';;
  esac
done
shift $((OPTIND-1))

OLD_VERSION=$1

if [[ -z "$OLD_VERSION" ]]; then
    echo "Error: Must provide version argument" 1>&2
    exit 1
fi

# export for update_code
export LUCKY_TAG=$OLD_VERSION

TYPE='add'
while getopts 's' flag; do
  case "${flag}" in
    s) TYPE='subtract' ;;
  esac
done

# rollback migration runs in current container to use newest code for rollback
CURRENT_VERSION=`git rev-parse --short=8 HEAD`

# additive migrations add to the db, so the new code relies on new stuff in the db
# and that means we have to remove that code before removing those db changes
# subtractive take away from the db, so the old code will break so we first deploy the new code
# which ignores the stuff we're about to take away and then take it away.
if [ "$TYPE" = "add" ]; then
  update_code
  rollback_db
else
  rollback_db
  update_code
fi

printf "\nâœ” All done.\n"
